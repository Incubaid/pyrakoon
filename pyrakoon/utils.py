# This file is part of Pyrakoon, a distributed key-value store client.
#
# Copyright (C) 2010 Incubaid BVBA
#
# Licensees holding a valid Incubaid license may use this file in
# accordance with Incubaid's Arakoon commercial license agreement. For
# more information on how to enter into this agreement, please contact
# Incubaid (contact details can be found on www.arakoon.org/licensing).
#
# Alternatively, this file may be redistributed and/or modified under
# the terms of the GNU Affero General Public License version 3, as
# published by the Free Software Foundation. Under this license, this
# file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU Affero General Public License for more details.
# You should have received a copy of the
# GNU Affero General Public License along with this program (file "COPYING").
# If not, see <http://www.gnu.org/licenses/>.

'''Utility functions'''

import __builtin__
import uuid
import functools
import itertools

def update_argspec(*argnames): #pylint: disable-msg=R0912
    '''Wrap a callable to use real argument names

    When generating functions at runtime, one often needs to fall back to
    ``*args`` and ``**kwargs`` usage. Using these features require
    well-documented code though, and renders API documentation tools less
    useful.

    The decorator generated by this function wraps a decorated function,
    which takes ``**kwargs``, into a function which takes the given argument
    names as parameters, and passes them to the decorated function as keyword
    arguments.

    The given argnames can be strings (for normal named arguments), or tuples
    of a string and a value (for arguments with default values). Only a couple
    of default value types are supported, an exception will be thrown when an
    unsupported value type is given.

    Example usage::

        >>> @update_argspec('a', 'b', 'c')
        ... def fun(**kwargs):
        ...     return kwargs['a'] + kwargs['b'] + kwargs['c']

        >>> import inspect
        >>> tuple(inspect.getargspec(fun))
        (['a', 'b', 'c'], None, None, None)

        >>> print fun(1, 2, 3)
        6
        >>> print fun(1, c=3, b=2)
        6

        >>> print fun(1, 2)
        Traceback (most recent call last):
            ...
        TypeError: fun() takes exactly 3 arguments (2 given)


        >>> @update_argspec()
        ... def g():
        ...     print 'Hello'

        >>> tuple(inspect.getargspec(g))
        ([], None, None, None)

        >>> g()
        Hello

        >>> @update_argspec('name', ('age', None))
        ... def hello(**kwargs):
        ...     name = kwargs['name']
        ...
        ...     if kwargs['age'] is None:
        ...         return 'Hello, %s' % name
        ...     else:
        ...         age = kwargs['age']
        ...         return 'Hello, %s, who is %d years old' % (name, age)

        >>> tuple(inspect.getargspec(hello))
        (['name', 'age'], None, None, (None,))

        >>> hello('Nicolas')
        'Hello, Nicolas'
        >>> hello('Nicolas', 25)
        'Hello, Nicolas, who is 25 years old'

    :param argnames: Names of the arguments to be used
    :type argnames: iterable of `str` or (`str`, `object`)

    :return: Decorator which wraps a given callable into one with a correct
        argspec
    :rtype: `callable`
    '''

    argnames_ = tuple(itertools.chain(argnames, ('', )))

    # Standard execution context, contains only what we actually need in the
    # function template
    context = {
        '__builtins__': None,
        'dict': __builtin__.dict,
        'zip': __builtin__.zip,
    }

    # Template for the function which will be compiled later on
    def _format(value):
        '''Format a value for display in a function signature'''

        if isinstance(value, unicode):
            return 'u\'%s\'' % value
        elif isinstance(value, str):
            return '\'%s\'' % value
        elif isinstance(value, (int, long)):
            return '%d' % value
        elif value is None:
            return 'None'
        else:
            raise TypeError

    def _generate_signature(args):
        '''Format arguments for display in a function signature'''

        for arg in args:
            if isinstance(arg, str):
                yield '%s' % arg
            else:
                arg, default = arg
                yield '%s=%s' % (arg, _format(default))

    template_signature = ', '.join(_generate_signature(argnames_))
    template_args = ', '.join(name if isinstance(name, str) else name[0] \
        for name in argnames_) if argnames_ else ''
    template_argnames = ', '.join(
        '\'%s\'' % (name if isinstance(name, str) else name[0])
        for name in argnames_) if argnames_ else ''

    fun_def_template = '''
def %%(name)s(%(signature)s):
    %%(kwargs_name)s = dict(zip((%(argnames)s), (%(args)s)))

    return %%(orig_name)s(**%%(kwargs_name)s)
''' % {
        'signature': template_signature,
        'args': template_args,
        'argnames': template_argnames,
    }

    def wrapper(fun):
        '''
        Decorating which wraps the decorated function in a callable which uses
        named arguments

        :param fun: Callable to decorate
        :type fun: `callable`

        :see: `update_argspec`
        '''

        # We need unique names for the variables used in the function template,
        # they shouldn't conflict with the arguments
        random_suffix = lambda: str(uuid.uuid4()).replace('-', '')

        orig_function_name = None
        while (not orig_function_name) or (orig_function_name in argnames_):
            orig_function_name = '_orig_%s' % random_suffix()

        kwargs_name = None
        while (not kwargs_name) or (kwargs_name in argnames_):
            kwargs_name = '_kwargs_%s' % random_suffix()


        # Fill in function template
        fun_def = fun_def_template % {
            'name': fun.__name__,
            'orig_name': orig_function_name,
            'kwargs_name': kwargs_name,
        }

        # Compile function to a code object
        code = compile(fun_def, '<update_argspec>', 'exec', 0, 1)

        # Create evaluation context
        env = context.copy()
        env[orig_function_name] = fun

        # Evaluate the code object in the evaluation context
        eval(code, env, env)

        # Retrieve the compiled/evaluated function
        fun_wrapper = env[fun.__name__]

        # Update __*__ attributes
        updated = functools.update_wrapper(fun_wrapper, fun)

        return updated

    return wrapper


def format_doc(doc):
    '''Try to format a docstring

    This function will split the given string on line boundaries, strip all
    lines, and stitch everything back together.

    :param doc: Docstring to format
    :type doc: `str` or `unicode`

    :return: Formatted docstring
    :rtype: `unicode`
    '''

    if isinstance(doc, str):
        doc = doc.decode('utf-8')

    return u'\n'.join(line.strip() for line in doc.splitlines())


def kill_coroutine(coroutine, log_fun=None):
    '''Kill a coroutine by injecting `StopIteration`

    If the coroutine has exited already, we ignore any errors.

    The provided `log_fun` function will be called when an unexpected error
    occurs. It should take a *message* argument.

    :param coroutine: Coroutine to kill
    :type coroutine: *generator*
    :param log_fun: Function to call when an exception is encountered
    :type log_fun: `callable`
    '''

    try:
        coroutine.throw(StopIteration)
    except StopIteration:
        # This is the normal, expected case
        pass
    except (KeyboardInterrupt, SystemExit):
        # Re-raise these
        raise
    except:
        try:
            log_fun('Failure while killing coroutine')
        except: #pylint: disable-msg=W0702
            pass
